diff --git a/node_modules/react-native-paper/src/components/Appbar/AppbarContent.tsx b/node_modules/react-native-paper/src/components/Appbar/AppbarContent.tsx
index 8b5e7f4..296426f 100644
--- a/node_modules/react-native-paper/src/components/Appbar/AppbarContent.tsx
+++ b/node_modules/react-native-paper/src/components/Appbar/AppbarContent.tsx
@@ -199,6 +199,7 @@ const AppbarContent = ({
         // @ts-expect-error We keep old a11y props for backwards compat with old RN versions
         accessibilityTraits={touchableRole}
         accessibilityComponentType="button"
+        accessbilityState={disabled ? 'disabled' : null}
         onPress={onPress}
         disabled={disabled}
         {...contentWrapperProps}
@@ -240,11 +241,7 @@ const styles = StyleSheet.create({
   },
 });
 
-const iosTouchableRole: readonly AccessibilityRole[] = ['button', 'header'];
-const touchableRole: AccessibilityRole = Platform.select({
-  ios: iosTouchableRole as unknown as 'button',
-  default: iosTouchableRole[0],
-});
+const touchableRole: AccessibilityRole = 'button';
 
 export default AppbarContent;
 
diff --git a/node_modules/react-native-paper/src/components/BottomNavigation/BottomNavigationBar.tsx b/node_modules/react-native-paper/src/components/BottomNavigation/BottomNavigationBar.tsx
index 0bfe303..789c388 100644
--- a/node_modules/react-native-paper/src/components/BottomNavigation/BottomNavigationBar.tsx
+++ b/node_modules/react-native-paper/src/components/BottomNavigation/BottomNavigationBar.tsx
@@ -360,7 +360,9 @@ const BottomNavigationBar = <Route extends BaseRoute>({
   navigationState,
   renderIcon,
   renderLabel,
-  renderTouchable = (props: TouchableProps<Route>) => <Touchable {...props} />,
+  renderTouchable = ({ key, ...props }: TouchableProps<Route>) => (
+    <Touchable key={key} {...props} />
+  ),
   getLabelText = ({ route }: { route: Route }) => route.title,
   getBadge = ({ route }: { route: Route }) => route.badge,
   getColor = ({ route }: { route: Route }) => route.color,
diff --git a/node_modules/react-native-paper/src/components/Button/Button.tsx b/node_modules/react-native-paper/src/components/Button/Button.tsx
index 64a049a..546b8ff 100644
--- a/node_modules/react-native-paper/src/components/Button/Button.tsx
+++ b/node_modules/react-native-paper/src/components/Button/Button.tsx
@@ -227,7 +227,13 @@ const Button = (
   );
 
   React.useEffect(() => {
-    elevation.setValue(isElevationEntitled ? initialElevation : 0);
+    // Workaround not to call setValue on Animated.Value, because it breaks styles.
+    // https://github.com/callstack/react-native-paper/issues/4559
+    Animated.timing(elevation, {
+      toValue: isElevationEntitled ? initialElevation : 0,
+      duration: 0,
+      useNativeDriver: true,
+    });
   }, [isElevationEntitled, elevation, initialElevation]);
 
   const handlePressIn = (e: GestureResponderEvent) => {
@@ -331,7 +337,7 @@ const Button = (
           buttonStyle,
           style,
           !isV3 && !disabled && { elevation },
-        ] as ViewStyle
+        ] as Animated.WithAnimatedValue<StyleProp<ViewStyle>>
       }
       {...(isV3 && { elevation: elevation })}
     >
diff --git a/node_modules/react-native-paper/src/components/Card/Card.tsx b/node_modules/react-native-paper/src/components/Card/Card.tsx
index a86e172..12cd22a 100644
--- a/node_modules/react-native-paper/src/components/Card/Card.tsx
+++ b/node_modules/react-native-paper/src/components/Card/Card.tsx
@@ -88,7 +88,7 @@ export type Props = $Omit<React.ComponentProps<typeof Surface>, 'mode'> & {
    * Style of card's inner content.
    */
   contentStyle?: StyleProp<ViewStyle>;
-  style?: StyleProp<ViewStyle>;
+  style?: Animated.WithAnimatedValue<StyleProp<ViewStyle>>;
   /**
    * @optional
    */
diff --git a/node_modules/react-native-paper/src/components/IconButton/IconButton.tsx b/node_modules/react-native-paper/src/components/IconButton/IconButton.tsx
index acf3cd1..e3cc65f 100644
--- a/node_modules/react-native-paper/src/components/IconButton/IconButton.tsx
+++ b/node_modules/react-native-paper/src/components/IconButton/IconButton.tsx
@@ -23,7 +23,7 @@ const PADDING = 8;
 
 type IconButtonMode = 'outlined' | 'contained' | 'contained-tonal';
 
-export type Props = $RemoveChildren<typeof TouchableRipple> & {
+export type Props = Omit<$RemoveChildren<typeof TouchableRipple>, 'style'> & {
   /**
    * Icon to display.
    */
diff --git a/node_modules/react-native-paper/src/components/Menu/Menu.tsx b/node_modules/react-native-paper/src/components/Menu/Menu.tsx
index f69b673..b20a22d 100644
--- a/node_modules/react-native-paper/src/components/Menu/Menu.tsx
+++ b/node_modules/react-native-paper/src/components/Menu/Menu.tsx
@@ -22,8 +22,8 @@ import {
 
 import MenuItem from './MenuItem';
 import { APPROX_STATUSBAR_HEIGHT } from '../../constants';
-import { withInternalTheme } from '../../core/theming';
-import type { $Omit, InternalTheme, MD3Elevation } from '../../types';
+import { useInternalTheme } from '../../core/theming';
+import type { MD3Elevation, ThemeProp } from '../../types';
 import { ElevationLevels } from '../../types';
 import { addEventListener } from '../../utils/addEventListener';
 import { BackHandler } from '../../utils/BackHandler/BackHandler';
@@ -84,7 +84,7 @@ export type Props = {
   /**
    * @optional
    */
-  theme: InternalTheme;
+  theme?: ThemeProp;
   /**
    * Inner ScrollView prop
    */
@@ -95,19 +95,6 @@ export type Props = {
   testID?: string;
 };
 
-type Layout = $Omit<$Omit<LayoutRectangle, 'x'>, 'y'>;
-
-type State = {
-  rendered: boolean;
-  top: number;
-  left: number;
-  menuLayout: Layout;
-  anchorLayout: Layout;
-  opacityAnimation: Animated.Value;
-  scaleAnimation: Animated.ValueXY;
-  windowLayout: Layout;
-};
-
 // Minimum padding between the edge of the screen and the menu
 const SCREEN_INDENT = 8;
 // From https://material.io/design/motion/speed.html#duration
@@ -124,6 +111,28 @@ export const ELEVATION_LEVELS_MAP = Object.values(
 
 const DEFAULT_MODE = 'elevated';
 
+const focusFirstDOMNode = (el: View | null | undefined) => {
+  if (el && Platform.OS === 'web') {
+    // When in the browser, we want to focus the first focusable item on toggle
+    // For example, when menu is shown, focus the first item in the menu
+    // And when menu is dismissed, send focus back to the button to resume tabbing
+    const node: any = findNodeHandle(el);
+    const focusableNode = node.querySelector(
+      // This is a rough list of selectors that can be focused
+      'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
+    );
+
+    focusableNode?.focus();
+  }
+};
+
+const isCoordinate = (anchor: any): anchor is { x: number; y: number } =>
+  !React.isValidElement(anchor) &&
+  typeof anchor?.x === 'number' &&
+  typeof anchor?.y === 'number';
+
+const isBrowser = () => Platform.OS === 'web' && 'document' in global;
+
 /**
  * Menus display a list of choices on temporary elevated surfaces. Their placement varies based on the element that opens them.
  *
@@ -170,166 +179,134 @@ const DEFAULT_MODE = 'elevated';
  * `Modal` contents within a `PaperProvider` in order for the menu to show. This
  * wrapping is not necessary if you use Paper's `Modal` instead.
  */
-class Menu extends React.Component<Props, State> {
-  // @component ./MenuItem.tsx
-  static Item = MenuItem;
-
-  static defaultProps = {
-    statusBarHeight: APPROX_STATUSBAR_HEIGHT,
-    overlayAccessibilityLabel: 'Close menu',
-    testID: 'menu',
-  };
-
-  static getDerivedStateFromProps(nextProps: Props, prevState: State) {
-    if (nextProps.visible && !prevState.rendered) {
-      return { rendered: true };
-    }
-
-    return null;
-  }
-
-  state = {
-    rendered: this.props.visible,
-    top: 0,
-    left: 0,
-    menuLayout: { width: 0, height: 0 },
-    anchorLayout: { width: 0, height: 0 },
-    opacityAnimation: new Animated.Value(0),
-    scaleAnimation: new Animated.ValueXY({ x: 0, y: 0 }),
-    windowLayout: {
-      width: WINDOW_LAYOUT.width,
-      height: WINDOW_LAYOUT.height,
-    },
-  };
 
-  componentDidMount() {
-    this.keyboardDidShowListener = Keyboard.addListener(
-      'keyboardDidShow',
-      this.keyboardDidShow
-    );
-    this.keyboardDidHideListener = Keyboard.addListener(
-      'keyboardDidHide',
-      this.keyboardDidHide
-    );
-  }
-
-  componentDidUpdate(prevProps: Props) {
-    if (prevProps.visible !== this.props.visible) {
-      this.updateVisibility();
+const Menu = ({
+  visible,
+  statusBarHeight = APPROX_STATUSBAR_HEIGHT,
+  overlayAccessibilityLabel = 'Close menu',
+  testID = 'menu',
+  anchor,
+  onDismiss,
+  anchorPosition,
+  contentStyle,
+  style,
+  elevation = DEFAULT_ELEVATION,
+  mode = DEFAULT_MODE,
+  children,
+  theme: themeOverrides,
+  keyboardShouldPersistTaps,
+}: Props) => {
+  const theme = useInternalTheme(themeOverrides);
+  const [rendered, setRendered] = React.useState(visible);
+  const [left, setLeft] = React.useState(0);
+  const [top, setTop] = React.useState(0);
+  const [menuLayout, setMenuLayout] = React.useState({ width: 0, height: 0 });
+  const [anchorLayout, setAnchorLayout] = React.useState({
+    width: 0,
+    height: 0,
+  });
+  const [windowLayout, setWindowLayout] = React.useState({
+    width: WINDOW_LAYOUT.width,
+    height: WINDOW_LAYOUT.height,
+  });
+
+  const opacityAnimationRef = React.useRef(new Animated.Value(0));
+  const scaleAnimationRef = React.useRef(new Animated.ValueXY({ x: 0, y: 0 }));
+  const keyboardHeightRef = React.useRef(0);
+  const prevVisible = React.useRef<boolean | null>(null);
+  const anchorRef = React.useRef<View | null>(null);
+  const menuRef = React.useRef<View | null>(null);
+  const prevRendered = React.useRef(false);
+
+  const keyboardDidShow = React.useCallback((e: RNKeyboardEvent) => {
+    const keyboardHeight = e.endCoordinates.height;
+    keyboardHeightRef.current = keyboardHeight;
+  }, []);
+
+  const keyboardDidHide = React.useCallback(() => {
+    keyboardHeightRef.current = 0;
+  }, []);
+
+  const keyboardDidShowListenerRef: React.MutableRefObject<
+    EmitterSubscription | undefined
+  > = React.useRef();
+  const keyboardDidHideListenerRef: React.MutableRefObject<
+    EmitterSubscription | undefined
+  > = React.useRef();
+
+  const backHandlerSubscriptionRef: React.MutableRefObject<
+    NativeEventSubscription | undefined
+  > = React.useRef();
+  const dimensionsSubscriptionRef: React.MutableRefObject<
+    NativeEventSubscription | undefined
+  > = React.useRef();
+
+  const handleDismiss = React.useCallback(() => {
+    if (visible) {
+      onDismiss?.();
     }
-  }
-
-  componentWillUnmount() {
-    this.removeListeners();
-    this.keyboardDidShowListener?.remove();
-    this.keyboardDidHideListener?.remove();
-  }
-
-  private anchor?: View | null = null;
-  private menu?: View | null = null;
-  private backHandlerSubscription: NativeEventSubscription | undefined;
-  private dimensionsSubscription: NativeEventSubscription | undefined;
-  private keyboardDidShowListener: EmitterSubscription | undefined;
-  private keyboardDidHideListener: EmitterSubscription | undefined;
-  private keyboardHeight: number = 0;
+  }, [onDismiss, visible]);
 
-  private isCoordinate = (anchor: any): anchor is { x: number; y: number } =>
-    !React.isValidElement(anchor) &&
-    typeof anchor?.x === 'number' &&
-    typeof anchor?.y === 'number';
-
-  private measureMenuLayout = () =>
-    new Promise<LayoutRectangle>((resolve) => {
-      if (this.menu) {
-        this.menu.measureInWindow((x, y, width, height) => {
-          resolve({ x, y, width, height });
-        });
+  const handleKeypress = React.useCallback(
+    (e: KeyboardEvent) => {
+      if (e.key === 'Escape') {
+        onDismiss?.();
       }
-    });
-
-  private measureAnchorLayout = () =>
-    new Promise<LayoutRectangle>((resolve) => {
-      const { anchor } = this.props;
-      if (this.isCoordinate(anchor)) {
-        resolve({ x: anchor.x, y: anchor.y, width: 0, height: 0 });
-        return;
-      }
-
-      if (this.anchor) {
-        this.anchor.measureInWindow((x, y, width, height) => {
-          resolve({ x, y, width, height });
-        });
-      }
-    });
-
-  private updateVisibility = async () => {
-    // Menu is rendered in Portal, which updates items asynchronously
-    // We need to do the same here so that the ref is up-to-date
-    await Promise.resolve();
-
-    if (this.props.visible) {
-      this.show();
-    } else {
-      this.hide();
-    }
-  };
-
-  private isBrowser = () => Platform.OS === 'web' && 'document' in global;
-
-  private focusFirstDOMNode = (el: View | null | undefined) => {
-    if (el && this.isBrowser()) {
-      // When in the browser, we want to focus the first focusable item on toggle
-      // For example, when menu is shown, focus the first item in the menu
-      // And when menu is dismissed, send focus back to the button to resume tabbing
-      const node: any = findNodeHandle(el);
-      const focusableNode = node.querySelector(
-        // This is a rough list of selectors that can be focused
-        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
-      );
-
-      focusableNode?.focus();
-    }
-  };
-
-  private handleDismiss = () => {
-    if (this.props.visible) {
-      this.props.onDismiss?.();
-    }
-    return true;
-  };
+    },
+    [onDismiss]
+  );
 
-  private handleKeypress = (e: KeyboardEvent) => {
-    if (e.key === 'Escape') {
-      this.props.onDismiss?.();
-    }
-  };
+  const removeListeners = React.useCallback(() => {
+    backHandlerSubscriptionRef.current?.remove();
+    dimensionsSubscriptionRef.current?.remove();
+    isBrowser() && document.removeEventListener('keyup', handleKeypress);
+  }, [handleKeypress]);
 
-  private attachListeners = () => {
-    this.backHandlerSubscription = addEventListener(
+  const attachListeners = React.useCallback(() => {
+    backHandlerSubscriptionRef.current = addEventListener(
       BackHandler,
       'hardwareBackPress',
-      this.handleDismiss
+      handleDismiss
     );
-    this.dimensionsSubscription = addEventListener(
+    dimensionsSubscriptionRef.current = addEventListener(
       Dimensions,
       'change',
-      this.handleDismiss
+      handleDismiss
     );
-    this.isBrowser() && document.addEventListener('keyup', this.handleKeypress);
-  };
+    Platform.OS === 'web' && document.addEventListener('keyup', handleKeypress);
+  }, [handleDismiss, handleKeypress]);
 
-  private removeListeners = () => {
-    this.backHandlerSubscription?.remove();
-    this.dimensionsSubscription?.remove();
-    this.isBrowser() &&
-      document.removeEventListener('keyup', this.handleKeypress);
-  };
+  const measureMenuLayout = () =>
+    new Promise<LayoutRectangle>((resolve) => {
+      if (menuRef.current) {
+        menuRef.current.measureInWindow((x, y, width, height) => {
+          resolve({ x, y, width, height });
+        });
+      }
+    });
 
-  private show = async () => {
-    const windowLayout = Dimensions.get('window');
-    const [menuLayout, anchorLayout] = await Promise.all([
-      this.measureMenuLayout(),
-      this.measureAnchorLayout(),
+  const measureAnchorLayout = React.useCallback(
+    () =>
+      new Promise<LayoutRectangle>((resolve) => {
+        if (isCoordinate(anchor)) {
+          resolve({ x: anchor.x, y: anchor.y, width: 0, height: 0 });
+          return;
+        }
+
+        if (anchorRef.current) {
+          anchorRef.current.measureInWindow((x, y, width, height) => {
+            resolve({ x, y, width, height });
+          });
+        }
+      }),
+    [anchor]
+  );
+
+  const show = React.useCallback(async () => {
+    const windowLayoutResult = Dimensions.get('window');
+    const [menuLayoutResult, anchorLayoutResult] = await Promise.all([
+      measureMenuLayout(),
+      measureAnchorLayout(),
     ]);
 
     // When visible is true for first render
@@ -339,355 +316,378 @@ class Menu extends React.Component<Props, State> {
     // so we have to wait until views are ready
     // and rerun this function to show menu
     if (
-      !windowLayout.width ||
-      !windowLayout.height ||
-      !menuLayout.width ||
-      !menuLayout.height ||
-      (!anchorLayout.width && !this.isCoordinate(this.props.anchor)) ||
-      (!anchorLayout.height && !this.isCoordinate(this.props.anchor))
+      !windowLayoutResult.width ||
+      !windowLayoutResult.height ||
+      !menuLayoutResult.width ||
+      !menuLayoutResult.height ||
+      (!anchorLayoutResult.width && !isCoordinate(anchor)) ||
+      (!anchorLayoutResult.height && !isCoordinate(anchor))
     ) {
-      requestAnimationFrame(this.show);
+      requestAnimationFrame(show);
       return;
     }
 
-    this.setState(
-      () => ({
-        left: anchorLayout.x,
-        top: anchorLayout.y,
-        anchorLayout: {
-          height: anchorLayout.height,
-          width: anchorLayout.width,
-        },
-        menuLayout: {
-          width: menuLayout.width,
-          height: menuLayout.height,
-        },
-        windowLayout: {
-          height: windowLayout.height - this.keyboardHeight,
-          width: windowLayout.width,
-        },
+    setLeft(anchorLayoutResult.x);
+    setTop(anchorLayoutResult.y);
+    setAnchorLayout({
+      height: anchorLayoutResult.height,
+      width: anchorLayoutResult.width,
+    });
+
+    setMenuLayout({
+      height: menuLayoutResult.height,
+      width: menuLayoutResult.width,
+    });
+
+    setWindowLayout({
+      height: windowLayoutResult.height - keyboardHeightRef.current,
+      width: windowLayoutResult.width,
+    });
+
+    attachListeners();
+    const { animation } = theme;
+    Animated.parallel([
+      Animated.timing(scaleAnimationRef.current, {
+        toValue: { x: menuLayoutResult.width, y: menuLayoutResult.height },
+        duration: ANIMATION_DURATION * animation.scale,
+        easing: EASING,
+        useNativeDriver: true,
       }),
-      () => {
-        this.attachListeners();
-
-        const { animation } = this.props.theme;
-        Animated.parallel([
-          Animated.timing(this.state.scaleAnimation, {
-            toValue: { x: menuLayout.width, y: menuLayout.height },
-            duration: ANIMATION_DURATION * animation.scale,
-            easing: EASING,
-            useNativeDriver: true,
-          }),
-          Animated.timing(this.state.opacityAnimation, {
-            toValue: 1,
-            duration: ANIMATION_DURATION * animation.scale,
-            easing: EASING,
-            useNativeDriver: true,
-          }),
-        ]).start(({ finished }) => {
-          if (finished) {
-            this.focusFirstDOMNode(this.menu);
-          }
-        });
+      Animated.timing(opacityAnimationRef.current, {
+        toValue: 1,
+        duration: ANIMATION_DURATION * animation.scale,
+        easing: EASING,
+        useNativeDriver: true,
+      }),
+    ]).start(({ finished }) => {
+      if (finished) {
+        focusFirstDOMNode(menuRef.current);
+        prevRendered.current = true;
       }
-    );
-  };
+    });
+  }, [anchor, attachListeners, measureAnchorLayout, theme]);
+
+  const hide = React.useCallback(() => {
+    removeListeners();
 
-  private hide = () => {
-    this.removeListeners();
+    const { animation } = theme;
 
-    const { animation } = this.props.theme;
-    Animated.timing(this.state.opacityAnimation, {
+    Animated.timing(opacityAnimationRef.current, {
       toValue: 0,
       duration: ANIMATION_DURATION * animation.scale,
       easing: EASING,
       useNativeDriver: true,
     }).start(({ finished }) => {
       if (finished) {
-        this.setState({ menuLayout: { width: 0, height: 0 }, rendered: false });
-        this.state.scaleAnimation.setValue({ x: 0, y: 0 });
-        this.focusFirstDOMNode(this.anchor);
+        setMenuLayout({ width: 0, height: 0 });
+        setRendered(false);
+        prevRendered.current = false;
+        focusFirstDOMNode(anchorRef.current);
       }
     });
-  };
+  }, [removeListeners, theme]);
+
+  const updateVisibility = React.useCallback(
+    async (display: boolean) => {
+      // Menu is rendered in Portal, which updates items asynchronously
+      // We need to do the same here so that the ref is up-to-date
+      await Promise.resolve().then(() => {
+        if (display && !prevRendered.current) {
+          show();
+        } else {
+          if (rendered) {
+            hide();
+          }
+        }
 
-  private keyboardDidShow = (e: RNKeyboardEvent) => {
-    const keyboardHeight = e.endCoordinates.height;
-    this.keyboardHeight = keyboardHeight;
-  };
+        return;
+      });
+    },
+    [hide, show, rendered]
+  );
 
-  private keyboardDidHide = () => {
-    this.keyboardHeight = 0;
-  };
+  React.useEffect(() => {
+    const opacityAnimation = opacityAnimationRef.current;
+    const scaleAnimation = scaleAnimationRef.current;
+    keyboardDidShowListenerRef.current = Keyboard.addListener(
+      'keyboardDidShow',
+      keyboardDidShow
+    );
+    keyboardDidHideListenerRef.current = Keyboard.addListener(
+      'keyboardDidHide',
+      keyboardDidHide
+    );
 
-  render() {
-    const {
-      visible,
-      anchor,
-      anchorPosition,
-      contentStyle,
-      style,
-      elevation = DEFAULT_ELEVATION,
-      mode = DEFAULT_MODE,
-      children,
-      theme,
-      statusBarHeight,
-      onDismiss,
-      overlayAccessibilityLabel,
-      keyboardShouldPersistTaps,
-      testID,
-    } = this.props;
-
-    const {
-      rendered,
-      menuLayout,
-      anchorLayout,
-      opacityAnimation,
-      scaleAnimation,
-      windowLayout,
-    } = this.state;
-
-    let { left, top } = this.state;
-
-    if (!this.isCoordinate(this.anchor) && anchorPosition === 'bottom') {
-      top += anchorLayout.height;
-    }
+    return () => {
+      removeListeners();
+      keyboardDidShowListenerRef.current?.remove();
+      keyboardDidHideListenerRef.current?.remove();
+      scaleAnimation.removeAllListeners();
+      opacityAnimation?.removeAllListeners();
+    };
+  }, [removeListeners, keyboardDidHide, keyboardDidShow]);
 
-    // I don't know why but on Android measure function is wrong by 24
-    const additionalVerticalValue = Platform.select({
-      android: statusBarHeight,
-      default: 0,
-    });
+  React.useEffect(() => {
+    if (prevVisible.current !== visible) {
+      prevVisible.current = visible;
 
-    const scaleTransforms = [
-      {
-        scaleX: scaleAnimation.x.interpolate({
-          inputRange: [0, menuLayout.width],
-          outputRange: [0, 1],
-        }),
-      },
-      {
-        scaleY: scaleAnimation.y.interpolate({
-          inputRange: [0, menuLayout.height],
-          outputRange: [0, 1],
-        }),
-      },
-    ];
+      if (visible !== rendered) {
+        setRendered(visible);
+      }
+    }
+  }, [visible, rendered]);
 
-    // We need to translate menu while animating scale to imitate transform origin for scale animation
-    const positionTransforms = [];
+  React.useEffect(() => {
+    updateVisibility(rendered);
+  }, [rendered, updateVisibility]);
 
-    // Check if menu fits horizontally and if not align it to right.
-    if (left <= windowLayout.width - menuLayout.width - SCREEN_INDENT) {
-      positionTransforms.push({
-        translateX: scaleAnimation.x.interpolate({
-          inputRange: [0, menuLayout.width],
-          outputRange: [-(menuLayout.width / 2), 0],
-        }),
-      });
+  React.useEffect(() => {
+    if (!isCoordinate(anchorRef.current) && anchorPosition === 'bottom') {
+      setTop((prev) => prev + anchorLayout.height);
+    }
+  }, [anchorPosition, anchorLayout.height]);
+
+  // I don't know why but on Android measure function is wrong by 24
+  const additionalVerticalValue = Platform.select({
+    android: statusBarHeight,
+    default: 0,
+  });
+
+  // We need to translate menu while animating scale to imitate transform origin for scale animation
+  const positionTransforms = [];
+  let leftTransformation = left;
+  let topTransformation = top;
+
+  // Check if menu fits horizontally and if not align it to right.
+  if (left <= windowLayout.width - menuLayout.width - SCREEN_INDENT) {
+    positionTransforms.push({
+      translateX: scaleAnimationRef.current.x.interpolate({
+        inputRange: [0, menuLayout.width],
+        outputRange: [-(menuLayout.width / 2), 0],
+      }),
+    });
 
-      // Check if menu position has enough space from left side
-      if (left < SCREEN_INDENT) {
-        left = SCREEN_INDENT;
-      }
-    } else {
-      positionTransforms.push({
-        translateX: scaleAnimation.x.interpolate({
-          inputRange: [0, menuLayout.width],
-          outputRange: [menuLayout.width / 2, 0],
-        }),
-      });
+    // Check if menu position has enough space from left side
+    if (leftTransformation < SCREEN_INDENT) {
+      leftTransformation = SCREEN_INDENT;
+    }
+  } else {
+    positionTransforms.push({
+      translateX: scaleAnimationRef.current.x.interpolate({
+        inputRange: [0, menuLayout.width],
+        outputRange: [menuLayout.width / 2, 0],
+      }),
+    });
 
-      left += anchorLayout.width - menuLayout.width;
+    leftTransformation += anchorLayout.width - menuLayout.width;
 
-      const right = left + menuLayout.width;
-      // Check if menu position has enough space from right side
-      if (right > windowLayout.width - SCREEN_INDENT) {
-        left = windowLayout.width - SCREEN_INDENT - menuLayout.width;
-      }
+    const right = leftTransformation + menuLayout.width;
+    // Check if menu position has enough space from right side
+    if (right > windowLayout.width - SCREEN_INDENT) {
+      leftTransformation =
+        windowLayout.width - SCREEN_INDENT - menuLayout.width;
     }
+  }
 
-    // If the menu is larger than available vertical space,
-    // calculate the height of scrollable view
-    let scrollableMenuHeight = 0;
+  // If the menu is larger than available vertical space,
+  // calculate the height of scrollable view
+  let scrollableMenuHeight = 0;
 
-    // Check if the menu should be scrollable
-    if (
-      // Check if the menu overflows from bottom side
-      top >=
-        windowLayout.height -
-          menuLayout.height -
-          SCREEN_INDENT -
-          additionalVerticalValue &&
-      // And bottom side of the screen has more space than top side
-      top <= windowLayout.height - top
-    ) {
-      // Scrollable menu should be below the anchor (expands downwards)
-      scrollableMenuHeight =
-        windowLayout.height - top - SCREEN_INDENT - additionalVerticalValue;
-    } else if (
-      // Check if the menu overflows from bottom side
-      top >=
-        windowLayout.height -
-          menuLayout.height -
-          SCREEN_INDENT -
-          additionalVerticalValue &&
-      // And top side of the screen has more space than bottom side
-      top >= windowLayout.height - top &&
-      // And menu overflows from top side
-      top <=
+  // Check if the menu should be scrollable
+  if (
+    // Check if the menu overflows from bottom side
+    topTransformation >=
+      windowLayout.height -
         menuLayout.height -
-          anchorLayout.height +
-          SCREEN_INDENT -
-          additionalVerticalValue
-    ) {
-      // Scrollable menu should be above the anchor (expands upwards)
-      scrollableMenuHeight =
-        top + anchorLayout.height - SCREEN_INDENT + additionalVerticalValue;
-    }
-
-    // Scrollable menu max height
+        SCREEN_INDENT -
+        additionalVerticalValue &&
+    // And bottom side of the screen has more space than top side
+    topTransformation <= windowLayout.height - topTransformation
+  ) {
+    // Scrollable menu should be below the anchor (expands downwards)
+    scrollableMenuHeight =
+      windowLayout.height -
+      topTransformation -
+      SCREEN_INDENT -
+      additionalVerticalValue;
+  } else if (
+    // Check if the menu overflows from bottom side
+    topTransformation >=
+      windowLayout.height -
+        menuLayout.height -
+        SCREEN_INDENT -
+        additionalVerticalValue &&
+    // And top side of the screen has more space than bottom side
+    topTransformation >= windowLayout.height - top &&
+    // And menu overflows from top side
+    topTransformation <=
+      menuLayout.height -
+        anchorLayout.height +
+        SCREEN_INDENT -
+        additionalVerticalValue
+  ) {
+    // Scrollable menu should be above the anchor (expands upwards)
     scrollableMenuHeight =
-      scrollableMenuHeight > windowLayout.height - 2 * SCREEN_INDENT
-        ? windowLayout.height - 2 * SCREEN_INDENT
-        : scrollableMenuHeight;
+      topTransformation +
+      anchorLayout.height -
+      SCREEN_INDENT +
+      additionalVerticalValue;
+  }
 
-    // Menu is typically positioned below the element that generates it
-    // So first check if it fits below the anchor (expands downwards)
-    if (
-      // Check if menu fits vertically
-      top <=
-        windowLayout.height -
-          menuLayout.height -
-          SCREEN_INDENT -
-          additionalVerticalValue ||
-      // Or if the menu overflows from bottom side
-      (top >=
-        windowLayout.height -
-          menuLayout.height -
-          SCREEN_INDENT -
-          additionalVerticalValue &&
-        // And bottom side of the screen has more space than top side
-        top <= windowLayout.height - top)
-    ) {
-      positionTransforms.push({
-        translateY: scaleAnimation.y.interpolate({
-          inputRange: [0, menuLayout.height],
-          outputRange: [-((scrollableMenuHeight || menuLayout.height) / 2), 0],
-        }),
-      });
+  // Scrollable menu max height
+  scrollableMenuHeight =
+    scrollableMenuHeight > windowLayout.height - 2 * SCREEN_INDENT
+      ? windowLayout.height - 2 * SCREEN_INDENT
+      : scrollableMenuHeight;
+
+  // Menu is typically positioned below the element that generates it
+  // So first check if it fits below the anchor (expands downwards)
+  if (
+    // Check if menu fits vertically
+    topTransformation <=
+      windowLayout.height -
+        menuLayout.height -
+        SCREEN_INDENT -
+        additionalVerticalValue ||
+    // Or if the menu overflows from bottom side
+    (topTransformation >=
+      windowLayout.height -
+        menuLayout.height -
+        SCREEN_INDENT -
+        additionalVerticalValue &&
+      // And bottom side of the screen has more space than top side
+      topTransformation <= windowLayout.height - topTransformation)
+  ) {
+    positionTransforms.push({
+      translateY: scaleAnimationRef.current.y.interpolate({
+        inputRange: [0, menuLayout.height],
+        outputRange: [-((scrollableMenuHeight || menuLayout.height) / 2), 0],
+      }),
+    });
 
-      // Check if menu position has enough space from top side
-      if (top < SCREEN_INDENT) {
-        top = SCREEN_INDENT;
-      }
-    } else {
-      positionTransforms.push({
-        translateY: scaleAnimation.y.interpolate({
-          inputRange: [0, menuLayout.height],
-          outputRange: [(scrollableMenuHeight || menuLayout.height) / 2, 0],
-        }),
-      });
+    // Check if menu position has enough space from top side
+    if (topTransformation < SCREEN_INDENT) {
+      topTransformation = SCREEN_INDENT;
+    }
+  } else {
+    positionTransforms.push({
+      translateY: scaleAnimationRef.current.y.interpolate({
+        inputRange: [0, menuLayout.height],
+        outputRange: [(scrollableMenuHeight || menuLayout.height) / 2, 0],
+      }),
+    });
 
-      top += anchorLayout.height - (scrollableMenuHeight || menuLayout.height);
-
-      const bottom =
-        top +
-        (scrollableMenuHeight || menuLayout.height) +
-        additionalVerticalValue;
-
-      // Check if menu position has enough space from bottom side
-      if (bottom > windowLayout.height - SCREEN_INDENT) {
-        top =
-          scrollableMenuHeight === windowLayout.height - 2 * SCREEN_INDENT
-            ? -SCREEN_INDENT * 2
-            : windowLayout.height -
-              menuLayout.height -
-              SCREEN_INDENT -
-              additionalVerticalValue;
-      }
+    topTransformation +=
+      anchorLayout.height - (scrollableMenuHeight || menuLayout.height);
+
+    const bottom =
+      topTransformation +
+      (scrollableMenuHeight || menuLayout.height) +
+      additionalVerticalValue;
+
+    // Check if menu position has enough space from bottom side
+    if (bottom > windowLayout.height - SCREEN_INDENT) {
+      topTransformation =
+        scrollableMenuHeight === windowLayout.height - 2 * SCREEN_INDENT
+          ? -SCREEN_INDENT * 2
+          : windowLayout.height -
+            menuLayout.height -
+            SCREEN_INDENT -
+            additionalVerticalValue;
     }
+  }
 
-    const shadowMenuContainerStyle = {
-      opacity: opacityAnimation,
-      transform: scaleTransforms,
-      borderRadius: theme.roundness,
-      ...(!theme.isV3 && { elevation: 8 }),
-      ...(scrollableMenuHeight ? { height: scrollableMenuHeight } : {}),
-    };
+  const shadowMenuContainerStyle = {
+    opacity: opacityAnimationRef.current,
+    transform: [
+      {
+        scaleX: scaleAnimationRef.current.x.interpolate({
+          inputRange: [0, menuLayout.width],
+          outputRange: [0, 1],
+        }),
+      },
+      {
+        scaleY: scaleAnimationRef.current.y.interpolate({
+          inputRange: [0, menuLayout.height],
+          outputRange: [0, 1],
+        }),
+      },
+    ],
+    borderRadius: theme.roundness,
+    ...(!theme.isV3 && { elevation: 8 }),
+    ...(scrollableMenuHeight ? { height: scrollableMenuHeight } : {}),
+  };
 
-    const positionStyle = {
-      top: this.isCoordinate(anchor) ? top : top + additionalVerticalValue,
-      ...(I18nManager.getConstants().isRTL ? { right: left } : { left }),
-    };
+  const positionStyle = {
+    top: isCoordinate(anchor)
+      ? topTransformation
+      : topTransformation + additionalVerticalValue,
+    ...(I18nManager.getConstants().isRTL
+      ? { right: leftTransformation }
+      : { left: leftTransformation }),
+  };
 
-    const pointerEvents = visible ? 'box-none' : 'none';
-
-    return (
-      <View
-        ref={(ref) => {
-          this.anchor = ref;
-        }}
-        collapsable={false}
-      >
-        {this.isCoordinate(anchor) ? null : anchor}
-        {rendered ? (
-          <Portal>
-            <Pressable
-              accessibilityLabel={overlayAccessibilityLabel}
-              accessibilityRole="button"
-              onPress={onDismiss}
-              style={styles.pressableOverlay}
-            />
-            <View
-              ref={(ref) => {
-                this.menu = ref;
-              }}
-              collapsable={false}
-              accessibilityViewIsModal={visible}
-              style={[styles.wrapper, positionStyle, style]}
+  const pointerEvents = visible ? 'box-none' : 'none';
+
+  return (
+    <View ref={(ref) => (anchorRef.current = ref)} collapsable={false}>
+      {isCoordinate(anchor) ? null : anchor}
+      {rendered ? (
+        <Portal>
+          <Pressable
+            accessibilityLabel={overlayAccessibilityLabel}
+            accessibilityRole="button"
+            onPress={onDismiss}
+            style={styles.pressableOverlay}
+          />
+          <View
+            ref={(ref) => (menuRef.current = ref)}
+            collapsable={false}
+            accessibilityViewIsModal={visible}
+            style={[styles.wrapper, positionStyle, style]}
+            pointerEvents={pointerEvents}
+            onAccessibilityEscape={onDismiss}
+            testID={`${testID}-view`}
+          >
+            <Animated.View
               pointerEvents={pointerEvents}
-              onAccessibilityEscape={onDismiss}
-              testID={`${testID}-view`}
+              style={{
+                transform: positionTransforms,
+              }}
             >
-              <Animated.View
+              <Surface
+                mode={mode}
                 pointerEvents={pointerEvents}
-                style={{
-                  transform: positionTransforms,
-                }}
+                style={[
+                  styles.shadowMenuContainer,
+                  shadowMenuContainerStyle,
+                  theme.isV3 && {
+                    backgroundColor:
+                      theme.colors.elevation[ELEVATION_LEVELS_MAP[elevation]],
+                  },
+                  contentStyle,
+                ]}
+                {...(theme.isV3 && { elevation })}
+                testID={`${testID}-surface`}
+                theme={theme}
               >
-                <Surface
-                  mode={mode}
-                  pointerEvents={pointerEvents}
-                  style={[
-                    styles.shadowMenuContainer,
-                    shadowMenuContainerStyle,
-                    theme.isV3 && {
-                      backgroundColor:
-                        theme.colors.elevation[ELEVATION_LEVELS_MAP[elevation]],
-                    },
-                    contentStyle,
-                  ]}
-                  {...(theme.isV3 && { elevation })}
-                  testID={`${testID}-surface`}
-                  theme={theme}
-                >
-                  {(scrollableMenuHeight && (
-                    <ScrollView
-                      keyboardShouldPersistTaps={keyboardShouldPersistTaps}
-                    >
-                      {children}
-                    </ScrollView>
-                  )) || <React.Fragment>{children}</React.Fragment>}
-                </Surface>
-              </Animated.View>
-            </View>
-          </Portal>
-        ) : null}
-      </View>
-    );
-  }
-}
+                {(scrollableMenuHeight && (
+                  <ScrollView
+                    keyboardShouldPersistTaps={keyboardShouldPersistTaps}
+                  >
+                    {children}
+                  </ScrollView>
+                )) || <React.Fragment>{children}</React.Fragment>}
+              </Surface>
+            </Animated.View>
+          </View>
+        </Portal>
+      ) : null}
+    </View>
+  );
+};
+
+Menu.Item = MenuItem;
 
 const styles = StyleSheet.create({
   wrapper: {
@@ -698,12 +698,14 @@ const styles = StyleSheet.create({
     paddingVertical: 8,
   },
   pressableOverlay: {
-    ...StyleSheet.absoluteFillObject,
-    ...(Platform.OS === 'web' && {
-      cursor: 'default',
+    ...Platform.select({
+      web: {
+        cursor: 'auto',
+      },
     }),
+    ...StyleSheet.absoluteFillObject,
     width: '100%',
   },
 });
 
-export default withInternalTheme(Menu);
+export default Menu;
\ No newline at end of file
diff --git a/node_modules/react-native-paper/src/components/Modal.tsx b/node_modules/react-native-paper/src/components/Modal.tsx
index 313ecee..173550d 100644
--- a/node_modules/react-native-paper/src/components/Modal.tsx
+++ b/node_modules/react-native-paper/src/components/Modal.tsx
@@ -112,27 +112,13 @@ function Modal({
   testID = 'modal',
 }: Props) {
   const theme = useInternalTheme(themeOverrides);
-  const visibleRef = React.useRef(visible);
-
-  React.useEffect(() => {
-    visibleRef.current = visible;
-  });
-
   const onDismissCallback = useLatestCallback(onDismiss);
-
   const { scale } = theme.animation;
-
   const { top, bottom } = useSafeAreaInsets();
-
   const opacity = useAnimatedValue(visible ? 1 : 0);
+  const [visibleInternal, setVisibleInternal] = React.useState(visible);
 
-  const [rendered, setRendered] = React.useState(visible);
-
-  if (visible && !rendered) {
-    setRendered(true);
-  }
-
-  const showModal = React.useCallback(() => {
+  const showModalAnimation = React.useCallback(() => {
     Animated.timing(opacity, {
       toValue: 1,
       duration: scale * DEFAULT_DURATION,
@@ -141,7 +127,7 @@ function Modal({
     }).start();
   }, [opacity, scale]);
 
-  const hideModal = React.useCallback(() => {
+  const hideModalAnimation = React.useCallback(() => {
     Animated.timing(opacity, {
       toValue: 0,
       duration: scale * DEFAULT_DURATION,
@@ -152,17 +138,24 @@ function Modal({
         return;
       }
 
-      if (visible) {
-        onDismissCallback();
-      }
-
-      if (visibleRef.current) {
-        showModal();
-      } else {
-        setRendered(false);
-      }
+      setVisibleInternal(false);
     });
-  }, [onDismissCallback, opacity, scale, showModal, visible]);
+  }, [opacity, scale]);
+
+  React.useEffect(() => {
+    if (visibleInternal === visible) {
+      return;
+    }
+
+    if (!visibleInternal && visible) {
+      setVisibleInternal(true);
+      return showModalAnimation();
+    }
+
+    if (visibleInternal && !visible) {
+      return hideModalAnimation();
+    }
+  }, [visible, showModalAnimation, hideModalAnimation, visibleInternal]);
 
   React.useEffect(() => {
     if (!visible) {
@@ -171,7 +164,7 @@ function Modal({
 
     const onHardwareBackPress = () => {
       if (dismissable || dismissableBackButton) {
-        hideModal();
+        onDismissCallback();
       }
 
       return true;
@@ -183,22 +176,11 @@ function Modal({
       onHardwareBackPress
     );
     return () => subscription.remove();
-  }, [dismissable, dismissableBackButton, hideModal, visible]);
-
-  const prevVisible = React.useRef<boolean | null>(null);
+  }, [dismissable, dismissableBackButton, onDismissCallback, visible]);
 
-  React.useEffect(() => {
-    if (prevVisible.current !== visible) {
-      if (visible) {
-        showModal();
-      } else {
-        hideModal();
-      }
-    }
-    prevVisible.current = visible;
-  });
-
-  if (!rendered) return null;
+  if (!visibleInternal) {
+    return null;
+  }
 
   return (
     <Animated.View
@@ -206,14 +188,14 @@ function Modal({
       accessibilityViewIsModal
       accessibilityLiveRegion="polite"
       style={StyleSheet.absoluteFill}
-      onAccessibilityEscape={hideModal}
+      onAccessibilityEscape={onDismissCallback}
       testID={testID}
     >
       <AnimatedPressable
         accessibilityLabel={overlayAccessibilityLabel}
         accessibilityRole="button"
         disabled={!dismissable}
-        onPress={dismissable ? hideModal : undefined}
+        onPress={dismissable ? onDismissCallback : undefined}
         importantForAccessibility="no"
         style={[
           styles.backdrop,
diff --git a/node_modules/react-native-paper/src/components/ProgressBar.tsx b/node_modules/react-native-paper/src/components/ProgressBar.tsx
index dcdaf48..790204f 100644
--- a/node_modules/react-native-paper/src/components/ProgressBar.tsx
+++ b/node_modules/react-native-paper/src/components/ProgressBar.tsx
@@ -203,7 +203,9 @@ const ProgressBar = ({
       accessibilityRole="progressbar"
       accessibilityState={{ busy: visible }}
       accessibilityValue={
-        indeterminate ? {} : { min: 0, max: 100, now: progress * 100 }
+        indeterminate
+          ? {}
+          : { min: 0, max: 100, now: Math.round(progress * 100) }
       }
       style={isWeb && styles.webContainer}
       testID={testID}
diff --git a/node_modules/react-native-paper/src/components/Surface.tsx b/node_modules/react-native-paper/src/components/Surface.tsx
index cc9f56b..b8e97b4 100644
--- a/node_modules/react-native-paper/src/components/Surface.tsx
+++ b/node_modules/react-native-paper/src/components/Surface.tsx
@@ -18,7 +18,7 @@ import { splitStyles } from '../utils/splitStyles';
 
 type Elevation = 0 | 1 | 2 | 3 | 4 | 5 | Animated.Value;
 
-export type Props = React.ComponentPropsWithRef<typeof View> & {
+export type Props = Omit<React.ComponentPropsWithRef<typeof View>, 'style'> & {
   /**
    * Content of the `Surface`.
    */
diff --git a/node_modules/react-native-paper/src/components/TextInput/TextInput.tsx b/node_modules/react-native-paper/src/components/TextInput/TextInput.tsx
index 4041699..88aa073 100644
--- a/node_modules/react-native-paper/src/components/TextInput/TextInput.tsx
+++ b/node_modules/react-native-paper/src/components/TextInput/TextInput.tsx
@@ -241,9 +241,8 @@ const TextInput = forwardRef<TextInputHandles, Props>(
       new Animated.Value(errorProp ? 1 : 0)
     );
     const [focused, setFocused] = React.useState<boolean>(false);
-    const [placeholder, setPlaceholder] = React.useState<string | undefined>(
-      ' '
-    );
+    const [displayPlaceholder, setDisplayPlaceholder] =
+      React.useState<boolean>(false);
     const [uncontrolledValue, setUncontrolledValue] = React.useState<
       string | undefined
     >(validInputValue);
@@ -328,24 +327,16 @@ const TextInput = forwardRef<TextInputHandles, Props>(
         // If the user wants to use the contextMenu, when changing the placeholder, the contextMenu is closed
         // This is a workaround to mitigate this behavior in scenarios where the placeholder is not specified.
         if (rest.placeholder) {
-          // Set the placeholder in a delay to offset the label animation
+          // Display placeholder in a delay to offset the label animation
           // If we show it immediately, they'll overlap and look ugly
           timer.current = setTimeout(
-            () => setPlaceholder(rest.placeholder),
+            () => setDisplayPlaceholder(true),
             50
           ) as unknown as NodeJS.Timeout;
         }
       } else {
         // hidePlaceholder
-
-        // Issue: https://github.com/callstack/react-native-paper/issues/3138
-        // Description:   Changing the placeholder text value dynamically,
-        //                within multiline input on iOS, doesn't work properly –
-        //                the placeholder is not displayed initially.
-        // Root cause:    Placeholder initial value, which has length 0.
-        // More context:  The issue was also reproduced in react-native, using its own TextInput.
-        // Workaround:    Set an empty space character in the default value.
-        setPlaceholder(' ');
+        setDisplayPlaceholder(false);
       }
 
       return () => {
@@ -500,7 +491,7 @@ const TextInput = forwardRef<TextInputHandles, Props>(
             labeled,
             error,
             focused,
-            placeholder,
+            displayPlaceholder,
             value,
             labelTextLayout,
             labelLayout,
@@ -542,7 +533,7 @@ const TextInput = forwardRef<TextInputHandles, Props>(
           labeled,
           error,
           focused,
-          placeholder,
+          displayPlaceholder,
           value,
           labelTextLayout,
           labelLayout,
diff --git a/node_modules/react-native-paper/src/components/TextInput/TextInputFlat.tsx b/node_modules/react-native-paper/src/components/TextInput/TextInputFlat.tsx
index 8a0dcb1..18a3233 100644
--- a/node_modules/react-native-paper/src/components/TextInput/TextInputFlat.tsx
+++ b/node_modules/react-native-paper/src/components/TextInput/TextInputFlat.tsx
@@ -229,6 +229,13 @@ const TextInputFlat = ({
     ? parentState.labeled
     : placeholderOpacityAnims[parentState.labelLayout.measured ? 1 : 0];
 
+  // We don't want to show placeholder if label is displayed, because they overlap.
+  // Before it was done by setting placeholder's value to " ", but inputs have the same props
+  // what causes broken styles due to: https://github.com/facebook/react-native/issues/48249
+  const placeholderTextColorBasedOnState = parentState.displayPlaceholder
+    ? placeholderTextColor ?? placeholderColor
+    : 'transparent';
+
   const minHeight =
     height ||
     (dense ? (label ? MIN_DENSE_HEIGHT_WL : MIN_DENSE_HEIGHT) : MIN_HEIGHT);
@@ -388,12 +395,12 @@ const TextInputFlat = ({
           ...rest,
           ref: innerRef,
           onChangeText,
-          placeholder: label ? parentState.placeholder : rest.placeholder,
+          placeholder: rest.placeholder,
           editable: !disabled && editable,
           selectionColor,
           cursorColor:
             typeof cursorColor === 'undefined' ? activeColor : cursorColor,
-          placeholderTextColor: placeholderTextColor ?? placeholderColor,
+          placeholderTextColor: placeholderTextColorBasedOnState,
           onFocus,
           onBlur,
           underlineColorAndroid: 'transparent',
diff --git a/node_modules/react-native-paper/src/components/TextInput/TextInputOutlined.tsx b/node_modules/react-native-paper/src/components/TextInput/TextInputOutlined.tsx
index 7f1fe92..16b668d 100644
--- a/node_modules/react-native-paper/src/components/TextInput/TextInputOutlined.tsx
+++ b/node_modules/react-native-paper/src/components/TextInput/TextInputOutlined.tsx
@@ -206,6 +206,10 @@ const TextInputOutlined = ({
     paddingHorizontal: INPUT_PADDING_HORIZONTAL,
   };
 
+  const placeholderTextColorBasedOnState = parentState.displayPlaceholder
+    ? placeholderTextColor ?? placeholderColor
+    : 'transparent';
+
   const labelBackgroundColor: ColorValue =
     backgroundColor === 'transparent'
       ? theme.colors.background
@@ -379,12 +383,12 @@ const TextInputOutlined = ({
           ref: innerRef,
           onLayout: onLayoutChange,
           onChangeText,
-          placeholder: label ? parentState.placeholder : rest.placeholder,
+          placeholder: rest.placeholder,
           editable: !disabled && editable,
           selectionColor,
           cursorColor:
             typeof cursorColor === 'undefined' ? activeColor : cursorColor,
-          placeholderTextColor: placeholderTextColor || placeholderColor,
+          placeholderTextColor: placeholderTextColorBasedOnState,
           onFocus,
           onBlur,
           underlineColorAndroid: 'transparent',
diff --git a/node_modules/react-native-paper/src/components/TextInput/types.tsx b/node_modules/react-native-paper/src/components/TextInput/types.tsx
index 7b7311b..4ec2952 100644
--- a/node_modules/react-native-paper/src/components/TextInput/types.tsx
+++ b/node_modules/react-native-paper/src/components/TextInput/types.tsx
@@ -72,7 +72,7 @@ export type State = {
   labeled: Animated.Value;
   error: Animated.Value;
   focused: boolean;
-  placeholder?: string;
+  displayPlaceholder: boolean;
   value?: string;
   labelTextLayout: { width: number };
   labelLayout: { measured: boolean; width: number; height: number };
diff --git a/node_modules/react-native-paper/src/components/TouchableRipple/Pressable.tsx b/node_modules/react-native-paper/src/components/TouchableRipple/Pressable.tsx
index 3fbda64..ec225cf 100644
--- a/node_modules/react-native-paper/src/components/TouchableRipple/Pressable.tsx
+++ b/node_modules/react-native-paper/src/components/TouchableRipple/Pressable.tsx
@@ -1,5 +1,6 @@
 import type * as React from 'react';
 import type {
+  Animated,
   PressableProps as PressableNativeProps,
   StyleProp,
   View,
@@ -26,7 +27,12 @@ export type PressableProps = Omit<
     | undefined;
   style?:
     | StyleProp<ViewStyle>
-    | ((state: PressableStateCallbackType) => StyleProp<ViewStyle>)
+    | Animated.WithAnimatedValue<StyleProp<ViewStyle>>
+    | ((
+        state: PressableStateCallbackType
+      ) =>
+        | StyleProp<ViewStyle>
+        | Animated.WithAnimatedValue<StyleProp<ViewStyle>>)
     | undefined;
 };
 
diff --git a/node_modules/react-native-paper/src/components/Typography/AnimatedText.tsx b/node_modules/react-native-paper/src/components/Typography/AnimatedText.tsx
index 43c2ff8..8e6552d 100644
--- a/node_modules/react-native-paper/src/components/Typography/AnimatedText.tsx
+++ b/node_modules/react-native-paper/src/components/Typography/AnimatedText.tsx
@@ -1,5 +1,11 @@
 import * as React from 'react';
-import { Animated, I18nManager, StyleSheet, TextStyle } from 'react-native';
+import {
+  Animated,
+  I18nManager,
+  StyleProp,
+  StyleSheet,
+  TextStyle,
+} from 'react-native';
 
 import type { VariantProp } from './types';
 import { useInternalTheme } from '../../core/theming';
@@ -21,7 +27,7 @@ type Props<T> = React.ComponentPropsWithRef<typeof Animated.Text> & {
    *  Body: `bodyLarge`, `bodyMedium`, `bodySmall`
    */
   variant?: VariantProp<T>;
-  style?: TextStyle;
+  style?: StyleProp<TextStyle>;
   /**
    * @optional
    */
